
New
+136
-0

#!/usr/bin/env python3
"""
Utility script to copy the RFMS-UPLOADER project into a target directory
(e.g., an external volume such as /Volumes/AiXDrive/AiModels) for testing or
deployment. By default the script excludes transient artifacts like virtual
environments, cached files, logs, and uploads to keep the copy lean.

Examples:
    python install_to_directory.py --target /Volumes/AiXDrive/AiModels
    python install_to_directory.py --target /tmp/rfms-copy --force --include-uploads
"""
from __future__ import annotations

import argparse
import shutil
from pathlib import Path

# Directories that are excluded by default from the export to avoid copying
# environment-specific or transient data.
DEFAULT_EXCLUDED_DIRS = {
    '.git',
    '.github',
    '.idea',
    '.vscode',
    '__pycache__',
    '.mypy_cache',
    '.pytest_cache',
    'logs',
    'instance',
    'uploads',
    '.venv',
    'env',
    'venv',
}

# Files that should not be copied by default because they are local artifacts.
DEFAULT_EXCLUDED_FILES = {
    'app.log',
}


def should_exclude(path: Path, *, include_uploads: bool) -> bool:
    """Return True if the given path should be excluded from the copy."""
    parts = set(path.parts)
    excluded_dirs = DEFAULT_EXCLUDED_DIRS.copy()
    if include_uploads:
        excluded_dirs.discard('uploads')

    if any(part in excluded_dirs for part in parts):
        return True
    if path.is_file() and path.name in DEFAULT_EXCLUDED_FILES:
        return True
    return False


def copy_project(source_root: Path, target_root: Path, *, include_uploads: bool) -> None:
    """Copy files from source_root to target_root respecting exclusion rules."""
    for path in source_root.rglob('*'):
        if should_exclude(path.relative_to(source_root), include_uploads=include_uploads):
            continue

        relative_path = path.relative_to(source_root)
        destination = target_root / relative_path

        if path.is_dir():
            destination.mkdir(parents=True, exist_ok=True)
            continue

        destination.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(path, destination)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Copy the project to a target directory for testing.")
    parser.add_argument(
        '--target',
        required=True,
        help='Destination directory for the project copy (e.g., /Volumes/AiXDrive/AiModels).'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Delete the target directory if it already exists before copying.'
    )
    parser.add_argument(
        '--include-uploads',
        action='store_true',
        help='Include the uploads directory in the copy.'
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    source_root = Path(__file__).resolve().parent
    target_root = Path(args.target).expanduser()

    # Prevent accidental recursive copies when the target sits inside the source tree.
    try:
        is_nested_target = target_root.resolve().is_relative_to(source_root)
    except AttributeError:  # Python < 3.9 compatibility
        try:
            target_root.resolve().relative_to(source_root)
            is_nested_target = True
        except ValueError:
            is_nested_target = False

    if is_nested_target:
        raise SystemExit(
            f"Target directory {target_root} cannot be inside the project root {source_root}; "
            "please choose a different destination."
        )

    if target_root.exists() and args.force:
        shutil.rmtree(target_root)

    if target_root.exists() and not args.force:
        raise SystemExit(
            f"Target directory {target_root} already exists. Re-run with --force to overwrite it."
        )

    target_root.mkdir(parents=True, exist_ok=True)

    copy_project(source_root, target_root, include_uploads=args.include_uploads)

    print(f"Project copied from {source_root} to {target_root}")
    print("Excluded by default: .git, virtual environments, caches, logs, instance, uploads")
    if args.include_uploads:
        print("Uploads were included in the copy.")
    else:
        print("Use --include-uploads to also copy uploaded assets.")


if __name__ == '__main__':
    main()
installer_portal.py
New
+413
-0

import os
from datetime import datetime, timedelta
from functools import wraps
from typing import List, Dict, Any

from flask import (
    Blueprint,
    current_app,
    flash,
    redirect,
    render_template,
    request,
    session,
    url_for,
)
from werkzeug.utils import secure_filename

from models import (
    db,
    Installer,
    WorkOrder,
    WorkOrderLine,
    InstallerInvoice,
    InvoiceLine,
    InvoiceAttachment,
)
from utils.rfms_client import RFMSClient

portal_bp = Blueprint('portal', __name__, url_prefix='/portal')
rfms_client = RFMSClient()


def ensure_default_installer_account(app):
    """Seed a default installer account from environment variables if configured."""
    default_email = os.getenv('INSTALLER_PORTAL_ADMIN_EMAIL')
    default_password = os.getenv('INSTALLER_PORTAL_ADMIN_PASSWORD')
    default_name = os.getenv('INSTALLER_PORTAL_ADMIN_NAME', 'Portal Admin')
    default_crew = os.getenv('INSTALLER_PORTAL_CREW_CODE')

    if not default_email or not default_password:
        return

    with app.app_context():
        existing = Installer.query.filter_by(email=default_email.lower()).first()
        if existing:
            return

        installer = Installer(
            name=default_name,
            email=default_email.lower(),
            crew_code=default_crew,
        )
        installer.set_password(default_password)
        db.session.add(installer)
        db.session.commit()
        current_app.logger.info("Default installer portal admin created")


def current_installer():
    installer_id = session.get('installer_id')
    if not installer_id:
        return None
    return Installer.query.get(installer_id)


def login_required(view_func):
    @wraps(view_func)
    def wrapper(*args, **kwargs):
        if not current_installer():
            flash('Please log in to access the installer portal.', 'warning')
            return redirect(url_for('portal.login'))
        return view_func(*args, **kwargs)

    return wrapper


def _normalize_jobs_response(jobs_payload: Any) -> List[Dict[str, Any]]:
    if isinstance(jobs_payload, list):
        return jobs_payload

    if not isinstance(jobs_payload, dict):
        return []

    detail = jobs_payload.get('detail') or jobs_payload.get('jobs')
    if isinstance(detail, dict):
        detail = detail.get('jobs') or detail.get('detail')
    return detail if isinstance(detail, list) else []


def _parse_order_lines(order_details: Dict[str, Any]) -> List[Dict[str, Any]]:
    if not isinstance(order_details, dict):
        return []

    product_sections: List[Dict[str, Any]] = []
    potential_sections = [
        order_details.get('products'),
        order_details.get('lineItems'),
    ]

    detail = order_details.get('detail')
    if isinstance(detail, dict):
        potential_sections.extend([
            detail.get('products'),
            detail.get('lineItems'),
        ])

    for section in potential_sections:
        if isinstance(section, list):
            product_sections = section
            break

    lines: List[Dict[str, Any]] = []
    for index, item in enumerate(product_sections):
        if not isinstance(item, dict):
            continue

        qty = float(item.get('quantity') or item.get('qty') or 0)
        unit_price = float(item.get('unitPrice') or item.get('price') or 0)
        total = float(item.get('extendedPrice') or item.get('total') or qty * unit_price)
        description = (
            item.get('description')
            or item.get('productDescription')
            or item.get('styleName')
            or 'RFMS Line'
        )
        lines.append({
            'source_line_number': item.get('lineNumber') or index + 1,
            'product_code': item.get('productCode') or item.get('productNumber'),
            'description': description,
            'quantity': qty,
            'unit_price': unit_price,
            'extended_price': total,
            'tax_rate': float(item.get('taxRate') or 0.1),
        })

    return lines


def _sync_work_order_lines(work_order: WorkOrder, order_details: Dict[str, Any]):
    lines = _parse_order_lines(order_details)
    if not lines:
        return

    existing_by_source = {
        line.source_line_number: line for line in work_order.lines if line.source_line_number is not None
    }

    for line_data in lines:
        source_num = line_data.get('source_line_number')
        line = existing_by_source.get(source_num)
        if not line:
            line = WorkOrderLine(work_order_id=work_order.id)

        line.source_line_number = source_num
        line.product_code = line_data.get('product_code')
        line.description = line_data.get('description')
        line.quantity = line_data.get('quantity') or 0
        line.unit_price = line_data.get('unit_price') or 0
        line.extended_price = line_data.get('extended_price') or (line.quantity * line.unit_price)
        line.tax_rate = line_data.get('tax_rate') if line_data.get('tax_rate') is not None else 0.1
        db.session.add(line)


def _hydrate_invoice_from_work_order(invoice: InstallerInvoice, work_order: WorkOrder):
    if invoice.lines:
        return

    for wo_line in work_order.lines:
        line_total = (wo_line.extended_price or 0) or (wo_line.quantity or 0) * (wo_line.unit_price or 0)
        new_line = InvoiceLine(
            invoice_id=invoice.id,
            work_order_line_id=wo_line.id,
            description=wo_line.description or 'Work order line',
            quantity=wo_line.quantity or 0,
            unit_price=wo_line.unit_price or 0,
            tax_rate=wo_line.tax_rate or 0.1,
            total=line_total,
        )
        db.session.add(new_line)


@portal_bp.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = (request.form.get('email') or '').lower().strip()
        password = request.form.get('password') or ''

        installer = Installer.query.filter_by(email=email, active=True).first()
        if installer and installer.check_password(password):
            session['installer_id'] = installer.id
            installer.updated_at = datetime.utcnow()
            db.session.commit()
            flash('Login successful.', 'success')
            return redirect(url_for('portal.dashboard'))

        flash('Invalid email or password.', 'danger')

    return render_template('portal_login.html')


@portal_bp.route('/logout')
@login_required
def logout():
    session.pop('installer_id', None)
    flash('You have been logged out.', 'info')
    return redirect(url_for('portal.login'))


@portal_bp.route('/dashboard')
@login_required
def dashboard():
    installer = current_installer()
    work_orders = WorkOrder.query.filter(
        (WorkOrder.installer_id == installer.id) | (WorkOrder.crew_code == installer.crew_code)
    ).order_by(WorkOrder.scheduled_start.asc().nulls_last()).all()

    invoices = InstallerInvoice.query.filter_by(installer_id=installer.id).order_by(
        InstallerInvoice.updated_at.desc()
    ).all()

    return render_template(
        'portal_dashboard.html',
        installer=installer,
        work_orders=work_orders,
        invoices=invoices,
    )


@portal_bp.route('/sync', methods=['POST'])
@login_required
def sync_jobs():
    installer = current_installer()
    week_offset = int(request.form.get('week_offset', 0))
    target_date = datetime.utcnow().date() + timedelta(weeks=week_offset)
    week_commencing = target_date - timedelta(days=target_date.weekday())
    week_end = week_commencing + timedelta(days=6)

    start_str = week_commencing.strftime('%m-%d-%Y')
    end_str = week_end.strftime('%m-%d-%Y')

    crews = [installer.crew_code] if installer.crew_code else None

    try:
        jobs_result = rfms_client.find_jobs_by_date_range(start_str, end_str, crews=crews)
        jobs = _normalize_jobs_response(jobs_result)
    except Exception as exc:  # pragma: no cover - defensive guard
        current_app.logger.error(f"Failed to sync jobs: {exc}", exc_info=True)
        flash('Failed to retrieve jobs from RFMS. Please try again later.', 'danger')
        return redirect(url_for('portal.dashboard'))

    imported = 0
    for job in jobs:
        if not isinstance(job, dict):
            continue

        order_number = job.get('orderNumber') or job.get('orderNum') or job.get('order')
        crew_name = job.get('crewName') or job.get('crew')
        job_number = job.get('jobNumber') or job.get('jobNum')

        scheduled_start = job.get('scheduledStartDate') or job.get('scheduledStart') or job.get('installStartDate')
        scheduled_end = job.get('scheduledEndDate') or job.get('scheduledEnd') or job.get('installEndDate')

        def _parse_date(value):
            if not value:
                return None
            if isinstance(value, datetime):
                return value
            try:
                return datetime.fromisoformat(value)
            except Exception:
                try:
                    return datetime.strptime(value, '%m-%d-%Y')
                except Exception:
                    return None

        work_order = WorkOrder.query.filter_by(order_number=order_number).first()
        if not work_order:
            work_order = WorkOrder(order_number=order_number)

        work_order.installer_id = installer.id
        work_order.job_number = job_number
        work_order.crew_name = crew_name
        work_order.crew_code = installer.crew_code
        work_order.scheduled_start = _parse_date(scheduled_start)
        work_order.scheduled_end = _parse_date(scheduled_end)
        work_order.status = job.get('status') or work_order.status or 'scheduled'
        work_order.week_commencing = week_commencing
        work_order.job_payload = job
        db.session.add(work_order)
        db.session.flush()

        if order_number:
            try:
                order_details = rfms_client.get_order(order_number)
                work_order.order_payload = order_details
                _sync_work_order_lines(work_order, order_details)
            except Exception as exc:  # pragma: no cover - defensive guard
                current_app.logger.warning(f"Unable to fetch order {order_number}: {exc}")

        imported += 1

    db.session.commit()

    flash(f'Synced {imported} job(s) for {week_commencing:%Y-%m-%d}.', 'success')
    return redirect(url_for('portal.dashboard'))


@portal_bp.route('/work-orders/<int:work_order_id>/invoice', methods=['GET', 'POST'])
@login_required
def edit_invoice(work_order_id: int):
    installer = current_installer()
    work_order = WorkOrder.query.get_or_404(work_order_id)

    if work_order.installer_id != installer.id and work_order.crew_code != installer.crew_code:
        flash('You do not have permission to view this work order.', 'danger')
        return redirect(url_for('portal.dashboard'))

    invoice = work_order.invoice
    if not invoice:
        invoice = InstallerInvoice(
            installer_id=installer.id,
            work_order_id=work_order.id,
            invoice_number=installer.generate_invoice_number(),
            status='draft',
        )
        db.session.add(invoice)
        db.session.flush()
        _hydrate_invoice_from_work_order(invoice, work_order)
        db.session.commit()

    if request.method == 'POST':
        descriptions = request.form.getlist('description[]')
        quantities = request.form.getlist('quantity[]')
        unit_prices = request.form.getlist('unit_price[]')
        tax_rates = request.form.getlist('tax_rate[]')
        line_ids = request.form.getlist('line_id[]')

        invoice.notes = request.form.get('notes')

        updated_lines: List[InvoiceLine] = []
        for idx, description in enumerate(descriptions):
            if not description.strip():
                continue

            line = None
            if idx < len(line_ids) and line_ids[idx]:
                line = InvoiceLine.query.get(int(line_ids[idx]))

            if not line:
                line = InvoiceLine(invoice_id=invoice.id)

            quantity = float(quantities[idx] or 0)
            unit_price = float(unit_prices[idx] or 0)
            tax_rate = float(tax_rates[idx] or 0.1)
            line_total = quantity * unit_price

            line.description = description
            line.quantity = quantity
            line.unit_price = unit_price
            line.tax_rate = tax_rate
            line.total = line_total * (1 + tax_rate)

            db.session.add(line)
            updated_lines.append(line)

        # Remove lines that were not included in the submission
        for existing in list(invoice.lines):
            if existing not in updated_lines:
                db.session.delete(existing)

        invoice.subtotal = sum(line.quantity * line.unit_price for line in invoice.lines)
        invoice.tax_amount = sum((line.quantity * line.unit_price) * line.tax_rate for line in invoice.lines)
        invoice.total = invoice.subtotal + invoice.tax_amount

        attachments = request.files.getlist('attachments')
        upload_dir = current_app.config.get('INVOICE_UPLOAD_FOLDER') or os.path.join(
            current_app.config['UPLOAD_FOLDER'],
            'invoices',
        )
        os.makedirs(upload_dir, exist_ok=True)

        for attachment in attachments:
            if not attachment.filename:
                continue
            filename = secure_filename(attachment.filename)
            stored_name = f"{invoice.invoice_number}_{int(datetime.utcnow().timestamp())}_{filename}"
            stored_path = os.path.join(upload_dir, stored_name)
            attachment.save(stored_path)

            invoice_attachment = InvoiceAttachment(
                invoice_id=invoice.id,
                filename=filename,
                stored_path=stored_path,
                mime_type=attachment.mimetype,
            )
            db.session.add(invoice_attachment)

        if request.form.get('action') == 'submit':
            invoice.status = 'submitted'
            invoice.submitted_at = datetime.utcnow()
            flash('Invoice submitted for processing.', 'success')
        else:
            flash('Invoice saved as draft.', 'success')

        db.session.commit()
        return redirect(url_for('portal.edit_invoice', work_order_id=work_order.id))

    return render_template(
        'invoice_editor.html',
        installer=installer,
        work_order=work_order,
        invoice=invoice,
    )
models.py
